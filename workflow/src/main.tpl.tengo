wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
ll := import("@platforma-sdk/workflow-tengo:ll")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
text := import("text")
liabilitiesCalcSw := assets.importSoftware("@platforma-open/milaboratories.antibody-sequence-liabilities.liabilities-calc-script:main")


wf.prepare(func(args) {
	clonotypingRunId := args.clonotypingRunId
	chain := args.chain
	isSingleCell := args.isSingleCell

	query := func(feature, isSingleCell) {
		queryUniversal := {
			type: "And",
			operands:  [
				{
					type: "Domain",
					domain: {
						"pl7.app/alphabet": "aminoacid",
          				"pl7.app/vdj/feature": feature
					},
					domainExactMatch: false
				},
				{
					type: "Name",
					name: "pl7.app/vdj/sequence"
				},
				{
					type: "AxesKeys",
					axesKeys: [
						{
							domain: {
								"pl7.app/vdj/clonotypingRunId": clonotypingRunId
							},
							domainExactMatch: false
						}
					],
					partialMatch: true
				}
			]
		}
		if !is_undefined(chain) {
			queryUniversal.operands[2].axesKeys[0].domain["pl7.app/vdj/chain"] = chain
			queryUniversal.operands[2].axesKeys[0].name = "pl7.app/vdj/clonotypeKey"
			return queryUniversal
		} else if isSingleCell {
			querySingleCell := []
			for ch in ["A", "B"] {
				queryTemp := {
					type: queryUniversal.type,
					operands: [
						{
							type: queryUniversal.operands[0].type,
							domain: {
								"pl7.app/alphabet": queryUniversal.operands[0].domain["pl7.app/alphabet"],
								"pl7.app/vdj/feature": queryUniversal.operands[0].domain["pl7.app/vdj/feature"],
								"pl7.app/vdj/scClonotypeChain": ch,
								"pl7.app/vdj/scClonotypeChain/index": "primary"
							},
							domainExactMatch: queryUniversal.operands[0].domainExactMatch
						},
						{
							type: queryUniversal.operands[2].type,
							axesKeys: [
								{
									domain: {
										"pl7.app/vdj/clonotypingRunId": queryUniversal.operands[2].axesKeys[0].domain["pl7.app/vdj/clonotypingRunId"]
									},
									domainExactMatch: queryUniversal.operands[2].axesKeys[0].domainExactMatch,
									name: "pl7.app/vdj/scClonotypeKey"
								}
							],
							partialMatch: queryUniversal.operands[2].partialMatch
						}
					]
				}
				querySingleCell += [queryTemp]
			}
			return querySingleCell
		}
	}

	ops := {
		single: true
	}

	ll.print("__THE_LOG__"+wf.query(query("CDR3", isSingleCell), ops).getDataAsJson())
	//ll.print("__THE_LOG__"+query("CDR1", isSingleCell))
	//ll.print("__THE_LOG__"+query("CDR2", isSingleCell))
	//ll.print("__THE_LOG__"+query("FR1", isSingleCell))

	if isSingleCell {
		return {
			data: wf.resolve(args.inputAnchor),
			hasCells: true,
			aaCDR3ColA: wf.query(query("CDR3", isSingleCell)[0], ops),
			aaCDR1ColA: wf.query(query("CDR1", isSingleCell)[0], ops),
			aaCDR2ColA: wf.query(query("CDR2", isSingleCell)[0], ops),
			aaFR1ColA: wf.query(query("FR1", isSingleCell)[0], ops),
			aaCDR3ColB: wf.query(query("CDR3", isSingleCell)[1], ops),
			aaCDR1ColB: wf.query(query("CDR1", isSingleCell)[1], ops),
			aaCDR2ColB: wf.query(query("CDR2", isSingleCell)[1], ops),
			aaFR1ColB: wf.query(query("FR1", isSingleCell)[1], ops)
		}
	} else {
		return {
			data: wf.resolve(args.inputAnchor),
			hasCells: false,
			aaCDR3ColA: wf.query(query("CDR3", isSingleCell), ops),
			aaCDR1ColA: wf.query(query("CDR1", isSingleCell), ops),
			aaCDR2ColA: wf.query(query("CDR2", isSingleCell), ops),
			aaFR1ColA: wf.query(query("FR1", isSingleCell), ops)
		}
	}
})

wf.body(func(args) {
	hasCells := args.hasCells
	columnsToExport := []
	if hasCells {
		aaCDR3ColA := args.aaCDR3ColA
		aaCDR1ColA := args.aaCDR1ColA
		aaCDR2ColA := args.aaCDR2ColA
		aaFR1ColA := args.aaFR1ColA
		aaCDR3ColB := args.aaCDR3ColB
		aaCDR1ColB := args.aaCDR1ColB
		aaCDR2ColB := args.aaCDR2ColB
		aaFR1ColB := args.aaFR1ColB
		columnsToExport = [aaCDR3ColA, aaCDR1ColA, aaCDR2ColA, aaFR1ColA, aaCDR3ColB, aaCDR1ColB, aaCDR2ColB, aaFR1ColB]
	} else {
		aaCDR3ColA := args.aaCDR3ColA
		aaCDR1ColA := args.aaCDR1ColA
		aaCDR2ColA := args.aaCDR2ColA
		aaFR1ColA := args.aaFR1ColA
		chain := args.chain
		columnsToExport = [aaCDR3ColA, aaCDR1ColA, aaCDR2ColA, aaFR1ColA]
	}
	clonotypingRunId := args.clonotypingRunId
	data := args.data
	ll.print("__THE_LOG__"+hasCells)
	
	clonotypeKeySpec := data.spec.axesSpec[1]

	tsv := xsv.exportFrame(columnsToExport, "tsv", {})

	liabilitiesCalcCmd := exec.builder().
		software(liabilitiesCalcSw).
		addFile("input.tsv", tsv).
		arg("input.tsv").
		saveFile("result.tsv").
		arg("result.tsv").
		run()

	result := liabilitiesCalcCmd.getFile("result.tsv")

	trace := pSpec.makeTrace(data.spec,
		{type: "milaboratories.antibody-sequence-liabilities", importance: 30, label: "Liabilities risk"})
	
	axes := []
	if hasCells {
		axes = [
			{
				column: "Clone label",
				id: "clone-label",
				spec: clonotypeKeySpec
			}
		]
	} else {
		axes = [
			{
				column: "Clonotype key",
				id: "clonotypeKey",
				spec: clonotypeKeySpec
			}
		]
	}

	columns := [
		{
			column: "Liabilities risk",
			id: "liabilitiesRisk",
			naRegex: "",
			allowNA: true,
			spec: {
				name: "pl7.app/vdj/liabilitiesRisk",
				valueType: "String",
				annotations: {
					"pl7.app/trace": trace.valueStr,
					"pl7.app/label": "Liabilities risk",
					"pl7.app/vdj/isScore": "true",
					"pl7.app/table/visibility": "default",
					"pl7.app/table/orderPriority": "100"
				}
			}
		}
	]
	
	columnsNames := ["CDR3", "CDR1", "CDR2", "FR1"]
	orderPriority := 99
	for colName in columnsNames {
		columns += [
			{
			column: colName + " liabilities",
			id: text.to_lower(colName) + "-liabilities",
			naRegex: "",
			allowNA: true,
			spec: {
				name: "pl7.app/vdj/" + text.to_lower(colName) + "Liabilities",
				valueType: "String",
				annotations: {
					"pl7.app/label": colName + " liabilities",
					"pl7.app/table/orderPriority": string(orderPriority)
					}
				}
			},
			{
			column: colName + " risk",
			id: text.to_lower(colName) + "-risk",
			naRegex: "",
			allowNA: true,
			spec: {
				name: "pl7.app/vdj/" + text.to_lower(colName) + "Risk",
				valueType: "String",
				annotations: {
					"pl7.app/label": colName + " risk",
					"pl7.app/table/orderPriority": string(orderPriority-1)
					}
				}
			}
		]
		orderPriority -= 1
	}

	outputSpecs := 
		{
			axes: axes,
			columns: columns,
			storageFormat: "Binary",
			partitionKeyLength: 0
		}
	
	outputLiabilities := xsv.importFile(
		result,
		"tsv",
		outputSpecs
	)

	return {
		outputs: {
			outputLiabilities: pframes.exportFrame(outputLiabilities)
		},

		exports: {
			exportLiabilities: {
				data: outputLiabilities["liabilitiesRisk.data"],
				spec: outputLiabilities["liabilitiesRisk.spec"]
			}
		}
	}
})
